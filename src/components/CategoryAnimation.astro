---
interface Props {
  category: string;
}

const { category } = Astro.props;
---

<div class="category-animation-wrapper" data-category={category}>
  <canvas id={`anim-canvas-${category}`} class="category-canvas"></canvas>
</div>

<style>
  .category-animation-wrapper {
    position: absolute;
    inset: 0;
    overflow: hidden;
    z-index: 0;
    pointer-events: none;
    mask-image: linear-gradient(to bottom, black 20%, transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, black 20%, transparent 100%);
  }
  .category-canvas {
    width: 100%;
    height: 100%;
    display: block;
    opacity: 0.35;
  }
</style>

<script>
  function initAnimations() {
    const wrappers = document.querySelectorAll('.category-animation-wrapper:not([data-initialized])');
    
    wrappers.forEach((wrapper) => {
      wrapper.setAttribute('data-initialized', 'true');
      const category = wrapper.getAttribute('data-category');
      const canvas = wrapper.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      let width = 0;
      let height = 0;

      const resize = () => {
        const rect = wrapper.getBoundingClientRect();
        // Handle high DPI displays
        const dpr = window.devicePixelRatio || 1;
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
      };
      
      window.addEventListener('resize', resize);
      resize();

      let animationFrameId: number;
      
      if (category === 'ai' || category === 'local-ai' || category === 'custom-ai') {
        // --- NEURAL NETWORK NODES ---
        const nodes: {x: number, y: number, vx: number, vy: number, radius: number}[] = [];
        const numNodes = Math.min(Math.floor(width * height / 12000), 80);
        
        for (let i = 0; i < numNodes; i++) {
          nodes.push({
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: Math.random() * 1.5 + 0.5
          });
        }

        const animateAI = () => {
          ctx.clearRect(0, 0, width, height);
          ctx.fillStyle = '#58a6ff';
          ctx.strokeStyle = 'rgba(88, 166, 255, 0.15)';
          ctx.lineWidth = 1;

          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            node.x += node.vx;
            node.y += node.vy;

            if (node.x < 0 || node.x > width) node.vx *= -1;
            if (node.y < 0 || node.y > height) node.vy *= -1;

            ctx.beginPath();
            ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
            ctx.fill();

            for (let j = i + 1; j < nodes.length; j++) {
              const other = nodes[j];
              const dx = node.x - other.x;
              const dy = node.y - other.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              if (dist < 120) {
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(other.x, other.y);
                const opacity = 1 - (dist / 120);
                ctx.strokeStyle = `rgba(88, 166, 255, ${opacity * 0.25})`;
                ctx.stroke();
              }
            }
          }
          animationFrameId = requestAnimationFrame(animateAI);
        };
        animateAI();

      } else if (category === 'infrastructure' || category === 'cloud') {
        // --- DATA PACKET TRAFFIC FLOW ---
        const lines: {y: number, speed: number, size: number, packets: {x: number, length: number}[]}[] = [];
        const numLines = Math.min(Math.floor(height / 40), 20);
        
        for (let i = 0; i < numLines; i++) {
          lines.push({
            y: Math.random() * height,
            speed: (Math.random() * 2 + 1) * (Math.random() > 0.5 ? 1 : -1),
            size: Math.random() * 2 + 1,
            packets: Array.from({length: Math.floor(Math.random() * 3 + 1)}, () => ({
              x: Math.random() * width,
              length: Math.random() * 40 + 10
            }))
          });
        }

        ctx.shadowBlur = 8;
        ctx.shadowColor = '#3fb950';

        const animateInfra = () => {
          ctx.clearRect(0, 0, width, height);

          for (const line of lines) {
            ctx.fillStyle = 'rgba(63, 185, 80, 0.1)';
            ctx.fillRect(0, line.y, width, 1);

            ctx.fillStyle = '#3fb950';
            for (const packet of line.packets) {
              packet.x += line.speed;
              
              if (line.speed > 0 && packet.x > width) packet.x = -packet.length;
              if (line.speed < 0 && packet.x < -packet.length) packet.x = width;

              ctx.fillRect(packet.x, line.y - line.size / 2, packet.length, line.size);
            }
          }
          animationFrameId = requestAnimationFrame(animateInfra);
        };
        animateInfra();

      } else {
        // --- MATRIX RAIN / TERMINAL SHIMMER ---
        const columns = Math.floor(width / 20);
        const drops: number[] = new Array(columns).fill(0).map(() => Math.random() * -100);
        const chars = '01ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ';

        const animateMatrix = () => {
          ctx.fillStyle = 'rgba(13, 17, 23, 0.1)';
          ctx.fillRect(0, 0, width, height);

          ctx.fillStyle = '#d29922'; // Terminal gold/amber
          ctx.font = '14px "Fira Code", monospace';
          
          for (let i = 0; i < drops.length; i++) {
            const text = chars[Math.floor(Math.random() * chars.length)];
            const x = i * 20;
            const y = drops[i] * 20;
            
            ctx.fillText(text, x, y);
            
            if (y > height && Math.random() > 0.975) {
              drops[i] = 0;
            }
            drops[i]++;
          }
          animationFrameId = requestAnimationFrame(animateMatrix);
        };
        // Throttle matrix animation slightly
        let lastTime = 0;
        const tick = (time: number) => {
          if (time - lastTime > 40) {
            animateMatrix();
            lastTime = time;
          } else {
            animationFrameId = requestAnimationFrame(tick);
          }
        };
        animationFrameId = requestAnimationFrame(tick);
      }
      
      // Cleanup on page unmount
      document.addEventListener('astro:before-swap', () => {
        cancelAnimationFrame(animationFrameId);
        window.removeEventListener('resize', resize);
      }, { once: true });
    });
  }

  // Setup on initial load and view transitions
  document.addEventListener('astro:page-load', initAnimations);
</script>
